const vmt_BT
 :BT.Start
const vmt_Tree
 :Tree.Init
 :Tree.SetRight
 :Tree.SetLeft
 :Tree.GetRight
 :Tree.GetLeft
 :Tree.GetKey
 :Tree.SetKey
 :Tree.GetHas_Right
 :Tree.GetHas_Left
 :Tree.SetHas_Left
 :Tree.SetHas_Right
 :Tree.Compare
 :Tree.Insert
 :Tree.Delete
 :Tree.Remove
 :Tree.RemoveRight
 :Tree.RemoveLeft
 :Tree.Search
 :Tree.Print
 :Tree.RecPrint
func Main()
t.0 = HeapAllocZ(4)
[t.0] = :vmt_BT
if t.0 goto :null0
	Error("null pointer")
null0:
t.1 = [t.0]
t.1 = [t.1+0]
t.2 = call t.1(t.0 )
PrintIntS(t.2)
ret
func BT.Start(this )
t.0 = HeapAllocZ(28)
[t.0] = :vmt_Tree
if t.0 goto :null1
	Error("null pointer")
null1:
root = t.0
t.1 = 16
t.2 = root
t.3 = [t.2]
t.3 = [t.3+0]
t.4 = call t.3(t.2 t.1 )
ntb = t.4
t.5 = root
t.6 = [t.5]
t.6 = [t.6+72]
t.7 = call t.6(t.5 )
ntb = t.7
t.8 = 100000000
PrintIntS(t.8)
t.9 = 8
t.10 = root
t.11 = [t.10]
t.11 = [t.11+48]
t.12 = call t.11(t.10 t.9 )
ntb = t.12
t.13 = root
t.14 = [t.13]
t.14 = [t.14+72]
t.15 = call t.14(t.13 )
ntb = t.15
t.16 = 24
t.17 = root
t.18 = [t.17]
t.18 = [t.18+48]
t.19 = call t.18(t.17 t.16 )
ntb = t.19
t.20 = 4
t.21 = root
t.22 = [t.21]
t.22 = [t.22+48]
t.23 = call t.22(t.21 t.20 )
ntb = t.23
t.24 = 12
t.25 = root
t.26 = [t.25]
t.26 = [t.26+48]
t.27 = call t.26(t.25 t.24 )
ntb = t.27
t.28 = 20
t.29 = root
t.30 = [t.29]
t.30 = [t.30+48]
t.31 = call t.30(t.29 t.28 )
ntb = t.31
t.32 = 28
t.33 = root
t.34 = [t.33]
t.34 = [t.34+48]
t.35 = call t.34(t.33 t.32 )
ntb = t.35
t.36 = 14
t.37 = root
t.38 = [t.37]
t.38 = [t.38+48]
t.39 = call t.38(t.37 t.36 )
ntb = t.39
t.40 = root
t.41 = [t.40]
t.41 = [t.41+72]
t.42 = call t.41(t.40 )
ntb = t.42
t.43 = 24
t.44 = root
t.45 = [t.44]
t.45 = [t.45+68]
t.46 = call t.45(t.44 t.43 )
PrintIntS(t.46)
t.47 = 12
t.48 = root
t.49 = [t.48]
t.49 = [t.49+68]
t.50 = call t.49(t.48 t.47 )
PrintIntS(t.50)
t.51 = 16
t.52 = root
t.53 = [t.52]
t.53 = [t.53+68]
t.54 = call t.53(t.52 t.51 )
PrintIntS(t.54)
t.55 = 50
t.56 = root
t.57 = [t.56]
t.57 = [t.57+68]
t.58 = call t.57(t.56 t.55 )
PrintIntS(t.58)
t.59 = 12
t.60 = root
t.61 = [t.60]
t.61 = [t.61+68]
t.62 = call t.61(t.60 t.59 )
PrintIntS(t.62)
t.63 = 12
t.64 = root
t.65 = [t.64]
t.65 = [t.65+52]
t.66 = call t.65(t.64 t.63 )
ntb = t.66
t.67 = root
t.68 = [t.67]
t.68 = [t.68+72]
t.69 = call t.68(t.67 )
ntb = t.69
t.70 = 12
t.71 = root
t.72 = [t.71]
t.72 = [t.72+68]
t.73 = call t.72(t.71 t.70 )
PrintIntS(t.73)
t.74 = 0
ret t.74
func Tree.Init(this v_key )
t.0 = v_key
[this + 12] = t.0
t.1 = 0
[this + 16] = t.1
t.2 = 0
[this + 20] = t.2
t.3 = 1
ret t.3
func Tree.SetRight(this rn )
t.0 = rn
[this + 8] = t.0
t.1 = 1
ret t.1
func Tree.SetLeft(this ln )
t.0 = ln
[this + 4] = t.0
t.1 = 1
ret t.1
func Tree.GetRight(this )
t.0 = [this + 8]
ret t.0
func Tree.GetLeft(this )
t.0 = [this + 4]
ret t.0
func Tree.GetKey(this )
t.0 = [this + 12]
ret t.0
func Tree.SetKey(this v_key )
t.0 = v_key
[this + 12] = t.0
t.1 = 1
ret t.1
func Tree.GetHas_Right(this )
t.0 = [this + 20]
ret t.0
func Tree.GetHas_Left(this )
t.0 = [this + 16]
ret t.0
func Tree.SetHas_Left(this val )
t.0 = val
[this + 16] = t.0
t.1 = 1
ret t.1
func Tree.SetHas_Right(this val )
t.0 = val
[this + 20] = t.0
t.1 = 1
ret t.1
func Tree.Compare(this num1 num2 )
t.0 = 0
ntb = t.0
t.1 = num2
t.2 = 1
t.3 = Add(t.1 t.2)
nti = t.3
t.4 = num1
t.5 = num2
t.6 = LtS(t.4 t.5)
if0 t.6 goto :if0_else
t.7 = 0
ntb = t.7
goto :if0_end
if0_else:
t.8 = num1
t.9 = nti
t.10 = LtS(t.8 t.9)
t.11 = Sub(1 t.10)
if0 t.11 goto :if1_else
t.12 = 0
ntb = t.12
goto :if1_end
if1_else:
t.13 = 1
ntb = t.13
if1_end:
if0_end:
t.14 = ntb
ret t.14
func Tree.Insert(this v_key )
t.0 = HeapAllocZ(28)
[t.0] = :vmt_Tree
if t.0 goto :null2
	Error("null pointer")
null2:
new_node = t.0
t.1 = v_key
t.2 = new_node
t.3 = [t.2]
t.3 = [t.3+0]
t.4 = call t.3(t.2 t.1 )
ntb = t.4
t.5 = this
current_node = t.5
t.6 = 1
cont = t.6
while0_top:
t.7 = cont
if0 t.7 goto :while0_end
t.8 = current_node
t.9 = [t.8]
t.9 = [t.9+20]
t.10 = call t.9(t.8 )
key_aux = t.10
t.11 = v_key
t.12 = key_aux
t.13 = LtS(t.11 t.12)
if0 t.13 goto :if2_else
t.14 = current_node
t.15 = [t.14]
t.15 = [t.15+32]
t.16 = call t.15(t.14 )
if0 t.16 goto :if3_else
t.17 = current_node
t.18 = [t.17]
t.18 = [t.18+16]
t.19 = call t.18(t.17 )
current_node = t.19
goto :if3_end
if3_else:
t.20 = 0
cont = t.20
t.21 = 1
t.22 = current_node
t.23 = [t.22]
t.23 = [t.23+36]
t.24 = call t.23(t.22 t.21 )
ntb = t.24
t.25 = new_node
t.26 = current_node
t.27 = [t.26]
t.27 = [t.27+8]
t.28 = call t.27(t.26 t.25 )
ntb = t.28
if3_end:
goto :if2_end
if2_else:
t.29 = current_node
t.30 = [t.29]
t.30 = [t.30+28]
t.31 = call t.30(t.29 )
if0 t.31 goto :if4_else
t.32 = current_node
t.33 = [t.32]
t.33 = [t.33+12]
t.34 = call t.33(t.32 )
current_node = t.34
goto :if4_end
if4_else:
t.35 = 0
cont = t.35
t.36 = 1
t.37 = current_node
t.38 = [t.37]
t.38 = [t.38+40]
t.39 = call t.38(t.37 t.36 )
ntb = t.39
t.40 = new_node
t.41 = current_node
t.42 = [t.41]
t.42 = [t.42+4]
t.43 = call t.42(t.41 t.40 )
ntb = t.43
if4_end:
if2_end:
goto :while0_top
while0_end:
t.44 = 1
ret t.44
func Tree.Delete(this v_key )
t.0 = this
current_node = t.0
t.1 = this
parent_node = t.1
t.2 = 1
cont = t.2
t.3 = 0
found = t.3
t.4 = 1
is_root = t.4
while1_top:
t.5 = cont
if0 t.5 goto :while1_end
t.6 = current_node
t.7 = [t.6]
t.7 = [t.7+20]
t.8 = call t.7(t.6 )
key_aux = t.8
t.9 = v_key
t.10 = key_aux
t.11 = LtS(t.9 t.10)
if0 t.11 goto :if5_else
t.12 = current_node
t.13 = [t.12]
t.13 = [t.13+32]
t.14 = call t.13(t.12 )
if0 t.14 goto :if6_else
t.15 = current_node
parent_node = t.15
t.16 = current_node
t.17 = [t.16]
t.17 = [t.17+16]
t.18 = call t.17(t.16 )
current_node = t.18
goto :if6_end
if6_else:
t.19 = 0
cont = t.19
if6_end:
goto :if5_end
if5_else:
t.20 = key_aux
t.21 = v_key
t.22 = LtS(t.20 t.21)
if0 t.22 goto :if7_else
t.23 = current_node
t.24 = [t.23]
t.24 = [t.24+28]
t.25 = call t.24(t.23 )
if0 t.25 goto :if8_else
t.26 = current_node
parent_node = t.26
t.27 = current_node
t.28 = [t.27]
t.28 = [t.28+12]
t.29 = call t.28(t.27 )
current_node = t.29
goto :if8_end
if8_else:
t.30 = 0
cont = t.30
if8_end:
goto :if7_end
if7_else:
t.31 = is_root
if0 t.31 goto :if9_else
t.32 = current_node
t.33 = [t.32]
t.33 = [t.33+28]
t.34 = call t.33(t.32 )
t.35 = Sub(1 t.34)
if0 t.35 goto :ss0_else
t.36 = current_node
t.37 = [t.36]
t.37 = [t.37+32]
t.38 = call t.37(t.36 )
t.39 = Sub(1 t.38)
goto :ss0_end
ss0_else:
t.39 = 0
ss0_end:
if0 t.39 goto :if10_else
t.40 = 1
ntb = t.40
goto :if10_end
if10_else:
t.41 = parent_node
t.42 = current_node
t.43 = this
t.44 = [this]
t.44 = [t.44+56]
t.45 = call t.44(this t.41 t.42 )
ntb = t.45
if10_end:
goto :if9_end
if9_else:
t.46 = parent_node
t.47 = current_node
t.48 = this
t.49 = [this]
t.49 = [t.49+56]
t.50 = call t.49(this t.46 t.47 )
ntb = t.50
if9_end:
t.51 = 1
found = t.51
t.52 = 0
cont = t.52
if7_end:
if5_end:
t.53 = 0
is_root = t.53
goto :while1_top
while1_end:
t.54 = found
ret t.54
func Tree.Remove(this p_node c_node )
t.0 = c_node
t.1 = [t.0]
t.1 = [t.1+32]
t.2 = call t.1(t.0 )
if0 t.2 goto :if11_else
t.3 = p_node
t.4 = c_node
t.5 = this
t.6 = [this]
t.6 = [t.6+64]
t.7 = call t.6(this t.3 t.4 )
ntb = t.7
goto :if11_end
if11_else:
t.8 = c_node
t.9 = [t.8]
t.9 = [t.9+28]
t.10 = call t.9(t.8 )
if0 t.10 goto :if12_else
t.11 = p_node
t.12 = c_node
t.13 = this
t.14 = [this]
t.14 = [t.14+60]
t.15 = call t.14(this t.11 t.12 )
ntb = t.15
goto :if12_end
if12_else:
t.16 = c_node
t.17 = [t.16]
t.17 = [t.17+20]
t.18 = call t.17(t.16 )
auxkey1 = t.18
t.19 = p_node
t.20 = [t.19]
t.20 = [t.20+16]
t.21 = call t.20(t.19 )
t.22 = [t.21]
t.22 = [t.22+20]
t.23 = call t.22(t.21 )
auxkey2 = t.23
t.24 = auxkey1
t.25 = auxkey2
t.26 = this
t.27 = [this]
t.27 = [t.27+44]
t.28 = call t.27(this t.24 t.25 )
if0 t.28 goto :if13_else
t.29 = [this + 24]
t.30 = p_node
t.31 = [t.30]
t.31 = [t.31+8]
t.32 = call t.31(t.30 t.29 )
ntb = t.32
t.33 = 0
t.34 = p_node
t.35 = [t.34]
t.35 = [t.35+36]
t.36 = call t.35(t.34 t.33 )
ntb = t.36
goto :if13_end
if13_else:
t.37 = [this + 24]
t.38 = p_node
t.39 = [t.38]
t.39 = [t.39+4]
t.40 = call t.39(t.38 t.37 )
ntb = t.40
t.41 = 0
t.42 = p_node
t.43 = [t.42]
t.43 = [t.43+40]
t.44 = call t.43(t.42 t.41 )
ntb = t.44
if13_end:
if12_end:
if11_end:
t.45 = 1
ret t.45
func Tree.RemoveRight(this p_node c_node )
while2_top:
t.0 = c_node
t.1 = [t.0]
t.1 = [t.1+28]
t.2 = call t.1(t.0 )
if0 t.2 goto :while2_end
t.3 = c_node
t.4 = [t.3]
t.4 = [t.4+12]
t.5 = call t.4(t.3 )
t.6 = [t.5]
t.6 = [t.6+20]
t.7 = call t.6(t.5 )
t.8 = c_node
t.9 = [t.8]
t.9 = [t.9+24]
t.10 = call t.9(t.8 t.7 )
ntb = t.10
t.11 = c_node
p_node = t.11
t.12 = c_node
t.13 = [t.12]
t.13 = [t.13+12]
t.14 = call t.13(t.12 )
c_node = t.14
goto :while2_top
while2_end:
t.15 = [this + 24]
t.16 = p_node
t.17 = [t.16]
t.17 = [t.17+4]
t.18 = call t.17(t.16 t.15 )
ntb = t.18
t.19 = 0
t.20 = p_node
t.21 = [t.20]
t.21 = [t.21+40]
t.22 = call t.21(t.20 t.19 )
ntb = t.22
t.23 = 1
ret t.23
func Tree.RemoveLeft(this p_node c_node )
while3_top:
t.0 = c_node
t.1 = [t.0]
t.1 = [t.1+32]
t.2 = call t.1(t.0 )
if0 t.2 goto :while3_end
t.3 = c_node
t.4 = [t.3]
t.4 = [t.4+16]
t.5 = call t.4(t.3 )
t.6 = [t.5]
t.6 = [t.6+20]
t.7 = call t.6(t.5 )
t.8 = c_node
t.9 = [t.8]
t.9 = [t.9+24]
t.10 = call t.9(t.8 t.7 )
ntb = t.10
t.11 = c_node
p_node = t.11
t.12 = c_node
t.13 = [t.12]
t.13 = [t.13+16]
t.14 = call t.13(t.12 )
c_node = t.14
goto :while3_top
while3_end:
t.15 = [this + 24]
t.16 = p_node
t.17 = [t.16]
t.17 = [t.17+8]
t.18 = call t.17(t.16 t.15 )
ntb = t.18
t.19 = 0
t.20 = p_node
t.21 = [t.20]
t.21 = [t.21+36]
t.22 = call t.21(t.20 t.19 )
ntb = t.22
t.23 = 1
ret t.23
func Tree.Search(this v_key )
t.0 = this
current_node = t.0
t.1 = 1
cont = t.1
t.2 = 0
ifound = t.2
while4_top:
t.3 = cont
if0 t.3 goto :while4_end
t.4 = current_node
t.5 = [t.4]
t.5 = [t.5+20]
t.6 = call t.5(t.4 )
key_aux = t.6
t.7 = v_key
t.8 = key_aux
t.9 = LtS(t.7 t.8)
if0 t.9 goto :if14_else
t.10 = current_node
t.11 = [t.10]
t.11 = [t.11+32]
t.12 = call t.11(t.10 )
if0 t.12 goto :if15_else
t.13 = current_node
t.14 = [t.13]
t.14 = [t.14+16]
t.15 = call t.14(t.13 )
current_node = t.15
goto :if15_end
if15_else:
t.16 = 0
cont = t.16
if15_end:
goto :if14_end
if14_else:
t.17 = key_aux
t.18 = v_key
t.19 = LtS(t.17 t.18)
if0 t.19 goto :if16_else
t.20 = current_node
t.21 = [t.20]
t.21 = [t.21+28]
t.22 = call t.21(t.20 )
if0 t.22 goto :if17_else
t.23 = current_node
t.24 = [t.23]
t.24 = [t.24+12]
t.25 = call t.24(t.23 )
current_node = t.25
goto :if17_end
if17_else:
t.26 = 0
cont = t.26
if17_end:
goto :if16_end
if16_else:
t.27 = 1
ifound = t.27
t.28 = 0
cont = t.28
if16_end:
if14_end:
goto :while4_top
while4_end:
t.29 = ifound
ret t.29
func Tree.Print(this )
t.0 = this
current_node = t.0
t.1 = current_node
t.2 = this
t.3 = [this]
t.3 = [t.3+76]
t.4 = call t.3(this t.1 )
ntb = t.4
t.5 = 1
ret t.5
func Tree.RecPrint(this node )
t.0 = node
t.1 = [t.0]
t.1 = [t.1+32]
t.2 = call t.1(t.0 )
if0 t.2 goto :if18_else
t.3 = node
t.4 = [t.3]
t.4 = [t.4+16]
t.5 = call t.4(t.3 )
t.6 = this
t.7 = [t.6]
t.7 = [t.7+76]
t.8 = call t.7(t.6 t.5 )
ntb = t.8
goto :if18_end
if18_else:
t.9 = 1
ntb = t.9
if18_end:
t.10 = node
t.11 = [t.10]
t.11 = [t.11+20]
t.12 = call t.11(t.10 )
PrintIntS(t.12)
t.13 = node
t.14 = [t.13]
t.14 = [t.14+28]
t.15 = call t.14(t.13 )
if0 t.15 goto :if19_else
t.16 = node
t.17 = [t.16]
t.17 = [t.17+12]
t.18 = call t.17(t.16 )
t.19 = this
t.20 = [t.19]
t.20 = [t.20+76]
t.21 = call t.20(t.19 t.18 )
ntb = t.21
goto :if19_end
if19_else:
t.22 = 1
ntb = t.22
if19_end:
t.23 = 1
ret t.23
func AllocArray(size)
bytes = MulS(size 4)
bytes = Add(bytes 4)
v = HeapAllocZ(bytes)
[v] = size
ret v
